{"version":3,"file":"index.js","sources":["../src/is-alphabet.ts","../src/is-ascii.ts","../src/is-base-32.ts","../src/is-base-64.ts","../src/is-bitcoin-address.ts","../src/is-json-object.ts","../src/is-rgb-color.ts","../src/is-date.ts","../src/is-decimal.ts"],"sourcesContent":["type LanguageType =\r\n  | \"en-US\"\r\n  | \"de-DE\"\r\n  | \"es-ES\"\r\n  | \"fr-FR\"\r\n  | \"ja-JP\"\r\n  | \"ru-RU\"\r\n  | \"th-TH\"\r\n  | \"vi-VN\"\r\n  | \"ko-KR\";\r\n\r\nconst alpha = {\r\n  \"en-US\": /^[A-Z]+$/i,\r\n  \"de-DE\": /^[A-ZÄÖÜß]+$/i,\r\n  \"es-ES\": /^[A-ZÁÉÍÑÓÚÜ]+$/i,\r\n  \"fr-FR\": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,\r\n  \"ja-JP\": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,\r\n  \"ru-RU\": /^[А-ЯЁ]+$/i,\r\n  \"th-TH\": /^[ก-๐\\s]+$/i,\r\n  \"vi-VN\":\r\n    /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,\r\n  \"ko-KR\": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,\r\n};\r\n\r\n/**\r\n * Validates if the given string contains only alphabetical letters.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is alphabet, false otherwise.\r\n */\r\nconst isAlphabet = (input: any, locale: LanguageType) => {\r\n  let string = input;\r\n\r\n  // Returns false input is not a string\r\n  if (typeof string !== \"string\") return false;\r\n\r\n  // Replace all white spaces and newlines with empty string\r\n  string = string.replace(/\\s/g, \"\").replace(/\\n|\\r/, \"\");\r\n\r\n  if (locale in alpha) return alpha[locale].test(string);\r\n\r\n  // Throws an error if locale does not exist\r\n  throw new Error(`Invalid locale '${locale}'`);\r\n};\r\n\r\nexport { isAlphabet, LanguageType };\r\n","const asciiRegex = /^[\\x00-\\x7F]+$/;\r\n\r\n/**\r\n * Validates if the given string contains only ascii letters.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is ascii characters, false otherwise.\r\n */\r\nconst isAscii = (input: any) => {\r\n  if (typeof input !== \"string\") return false;\r\n  return asciiRegex.test(input);\r\n};\r\n\r\nexport { isAscii };\r\n","const base32Regex = /^[A-Z2-7]+=*$/;\r\n\r\n/**\r\n * Validates if the given string is Base32 format or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is Base32 string, false otherwise.\r\n */\r\nconst isBase32 = (input: any) => {\r\n  // Returns false input is not a string\r\n  if (typeof input !== \"string\") return false;\r\n\r\n  // Check if string is Base64 format\r\n  if (input.length % 8 === 0 && base32Regex.test(input)) return true;\r\n\r\n  return false;\r\n};\r\n\r\nexport { isBase32 };\r\n","const notBase64Regex = /[^A-Z0-9+\\/=]/i;\r\nconst urlSafeBase64Regex = /^[A-Z0-9_\\-]*$/i;\r\n\r\ninterface Options {\r\n  isUrlSafe: boolean;\r\n}\r\n\r\n/**\r\n * Validates if the given string is Base64 format or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @param {Options} options An optional configuration object.\r\n * @param {boolean} options.isUrlSafe Tests the string is url safe.\r\n * @returns {boolean} Returns true if the string is Base64 string, false otherwise.\r\n */\r\nconst isBase64 = (input: any, options?: Options) => {\r\n  // Returns false input is not a string\r\n  if (typeof input !== \"string\") return false;\r\n\r\n  // Check if string is URL Base64 format\r\n  if (options?.isUrlSafe) return urlSafeBase64Regex.test(input);\r\n\r\n  const len = input.length;\r\n\r\n  // If string is not matched with Base64 regex\r\n  if (len % 4 !== 0 || notBase64Regex.test(input)) return false;\r\n\r\n  // Find the first \"=\" character\r\n  const firstPaddingChar = input.indexOf(\"=\");\r\n\r\n  // If does not exist \"=\" character\r\n  if (firstPaddingChar === -1) return true;\r\n\r\n  // If string ends with \"=\" character\r\n  if (firstPaddingChar === len - 1) return true;\r\n\r\n  // If string ends with double \"=\" character\r\n  if (firstPaddingChar === len - 2 && input[len - 1] === \"=\") return true;\r\n\r\n  return false;\r\n};\r\n\r\nexport { isBase64 };\r\n","const bech32Regex = /^(bc1|tb1|bc1p|tb1p)[ac-hj-np-z02-9]{39,58}$/;\r\nconst base58Regex = /^(1|2|3|m)[A-HJ-NP-Za-km-z1-9]{25,39}$/;\r\n\r\n/**\r\n * Validates if the given string is Bitcoin address or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is BTC address, false otherwise.\r\n */\r\nconst isBitcoinAddress = (input: any) => {\r\n  if (typeof input !== \"string\") return false;\r\n  return bech32Regex.test(input) || base58Regex.test(input);\r\n};\r\n\r\nexport { isBitcoinAddress };\r\n","/**\r\n * Validates if the given string is JSON format or not by JSON.parse.\r\n *\r\n * @param {string} input - The string to validate.\r\n * @returns {boolean} - Returns true if the string is JSON format, false otherwise.\r\n */\r\nconst isStrictJSON = (input: string) => {\r\n  try {\r\n    JSON.parse(input);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Validates if the given input is JSON object or array of objects.\r\n *\r\n * @param {any} input The input to validate.\r\n * @returns {boolean} Returns true if the input is JSON object or array of objects, false otherwise.\r\n */\r\nconst isValidObject = (input: any) => {\r\n  if (Array.isArray(input)) return input.every(isValidObject);\r\n  return typeof input === \"object\" && input !== null;\r\n};\r\n\r\n/**\r\n * Validates if the given string is JSON format or not.\r\n *\r\n * The JSON string must be in type of key/value pairs.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is JSON format, false otherwise.\r\n */\r\nconst isJsonObject = (input: any) => {\r\n  let string = input;\r\n\r\n  // Returns false input is not a string\r\n  if (typeof string !== \"string\") return false;\r\n\r\n  // Replace all white spaces and newlines with empty string\r\n  string = string.replace(/\\s/g, \"\").replace(/\\n|\\r/, \"\");\r\n\r\n  // Check if the string is JSON object\r\n  const isObjectFormat = /^\\{.*\\}$/.test(string);\r\n  if (isObjectFormat) return isStrictJSON(string);\r\n\r\n  // Check if the string is JSON array\r\n  const isArrayFormat = /^\\[.*\\]$/.test(string);\r\n  if (isArrayFormat) {\r\n    const isValidArray = isStrictJSON(string);\r\n    if (!isValidArray) return false;\r\n    const array = JSON.parse(string) as Array<any>;\r\n    return isValidObject(array);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport { isJsonObject };\r\n","const rgbColor =\r\n  /^rgb\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\)$/;\r\nconst rgbaColor =\r\n  /^rgba\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)$/;\r\nconst rgbColorPercent =\r\n  /^rgb\\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\\)$/;\r\nconst rgbaColorPercent =\r\n  /^rgba\\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)$/;\r\n\r\n/**\r\n * Validates if the given string is RGB (or RGBA) color or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @returns {boolean} Returns true if the string is RGB, false otherwise.\r\n */\r\nconst isRgbColor = (input: any) => {\r\n  let string = input;\r\n\r\n  // Returns false input is not a string\r\n  if (typeof string !== \"string\") return false;\r\n\r\n  // Replace all white spaces and newlines with empty string\r\n  string = string.replace(/\\s/g, \"\").replace(/\\n|\\r/, \"\");\r\n\r\n  return (\r\n    rgbColor.test(string) ||\r\n    rgbaColor.test(string) ||\r\n    rgbColorPercent.test(string) ||\r\n    rgbaColorPercent.test(string)\r\n  );\r\n};\r\n\r\nexport { isRgbColor };\r\n","interface Options {\r\n  format?: string;\r\n  delimiters?: string[];\r\n  strictMode?: boolean;\r\n}\r\n\r\n/**\r\n * Check is valid format with type like \"yyyy-mm-dd\", \"mm.dd.yyyy\", \"dd/mm/yy\", ...\r\n *\r\n * @param {string[]} format The format need to validate.\r\n * @returns {boolean} Returns true if is valid format.\r\n */\r\nconst checkIsValidFormat = (format: string) =>\r\n  /(^(y{4}|y{2})[.\\/-](m{1,2})[.\\/-](d{1,2})$)|(^(m{1,2})[.\\/-](d{1,2})[.\\/-]((y{4}|y{2})$))|(^(d{1,2})[.\\/-](m{1,2})[.\\/-]((y{4}|y{2})$))/gi.test(\r\n    format\r\n  );\r\n\r\n/**\r\n * Generate array of each date value and format value pairs.\r\n *\r\n * @param {string[]} date The date array.\r\n * @param {string[]} format The format array.\r\n * @returns {boolean} Returns the list of date and value pairs.\r\n */\r\nconst zip = (date: string[], format: string[]) => {\r\n  const zippedArr = [];\r\n\r\n  const len = Math.max(date.length, format.length);\r\n\r\n  for (let i = 0; i < len; i++) {\r\n    zippedArr.push([date[i], format[i]]);\r\n  }\r\n\r\n  return zippedArr;\r\n};\r\n\r\n/**\r\n * Validates if the given string is date string or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @param {Options} options An optional configuration object.\r\n * @param {boolean} options.format The format of date string.\r\n * @param {boolean} options.strictMode Match exactly format.\r\n * @returns {boolean} Returns true if the string is date string, false otherwise.\r\n */\r\nconst isDate = (input: any, options?: Options) => {\r\n  // Delimiters between day,month and year\r\n  const delimiters = [\"/\", \"-\", \".\"];\r\n\r\n  // Set default options value\r\n  const format = options?.format || \"YYYY/MM/DD\";\r\n  const strictMode = Boolean(options?.strictMode);\r\n\r\n  // Returns false input is not a string\r\n  if (typeof input !== \"string\") return false;\r\n\r\n  // If format is invalid, return false\r\n  if (!checkIsValidFormat(format)) return false;\r\n\r\n  // Find the delimiter of format string\r\n  const formatDelimiter = delimiters.find(\r\n    (delimiter) => format.indexOf(delimiter) !== -1\r\n  );\r\n\r\n  // Find the delimiter of input string,\r\n  // if is in strict mode then input delimiter is the same as format delimiter\r\n  const dateDelimiter = strictMode\r\n    ? formatDelimiter\r\n    : delimiters.find((delimiter) => input.indexOf(delimiter) !== -1);\r\n\r\n  // Get the list of date value and format pairs\r\n  const dateAndFormat = zip(\r\n    input.split(dateDelimiter),\r\n    format.toLowerCase().split(formatDelimiter)\r\n  );\r\n\r\n  const dateObj: any = {};\r\n\r\n  // Iterate all date value and format pairs\r\n  for (const [dateWord, formatWord] of dateAndFormat) {\r\n    // Date value and format need to exist and have the same length\r\n    if (!dateWord || !formatWord || dateWord.length !== formatWord.length)\r\n      return false;\r\n\r\n    // Add value to dateObj with key is y,m,d\r\n    dateObj[formatWord.charAt(0)] = dateWord;\r\n  }\r\n\r\n  let fullYear = dateObj.y;\r\n\r\n  // Check if the year starts with a hyphen\r\n  if (fullYear.startsWith(\"-\")) return false;\r\n\r\n  // Convert short year to full year\r\n  if (dateObj.y.length === 2) {\r\n    const parsedYear = parseInt(dateObj.y, 10);\r\n\r\n    // If year is not a number, return false\r\n    if (isNaN(parsedYear)) return false;\r\n\r\n    const currentYearLastTwoDigits = new Date().getFullYear() % 100;\r\n\r\n    // Format year based on last 2 digits\r\n    if (parsedYear < currentYearLastTwoDigits) {\r\n      fullYear = `20${dateObj.y}`;\r\n    } else {\r\n      fullYear = `19${dateObj.y}`;\r\n    }\r\n  }\r\n\r\n  let month = dateObj.m;\r\n\r\n  // Format month if it has 1 character\r\n  if (dateObj.m.length === 1) {\r\n    month = `0${dateObj.m}`;\r\n  }\r\n\r\n  let day = dateObj.d;\r\n\r\n  // Format day if it has 1 character\r\n  if (dateObj.d.length === 1) {\r\n    day = `0${dateObj.d}`;\r\n  }\r\n\r\n  // Check if date instance is valid\r\n  return (\r\n    new Date(`${fullYear}-${month}-${day}T00:00:00.000Z`).getUTCDate() ===\r\n    +dateObj.d\r\n  );\r\n};\r\n\r\nexport { isDate };\r\n","interface Options {\r\n  force?: boolean;\r\n  digits?: number;\r\n}\r\n\r\n/**\r\n * Validates if the given string decimal or not.\r\n *\r\n * @param {any} input The string to validate.\r\n * @param {any} options.digits The digits of decimal.\r\n * @param {any} options.force Check exactly a decimal with dot symbol and digits.\r\n * @returns {boolean} Returns true if the string decimal number, false otherwise.\r\n */\r\nconst isDecimal = (input: any, options?: Options) => {\r\n  // Returns false input is not a string\r\n  if (typeof input !== \"string\") return false;\r\n\r\n  // Add default options value\r\n  const digits = options?.digits || 1;\r\n  const force = Boolean(options?.force);\r\n\r\n  // Make a regex of digits and force digits number\r\n  const regExp = new RegExp(\r\n    `^[-+]?([0-9]+)?(\\\\.[0-9]{${digits},})${force ? \"\" : \"?\"}$`\r\n  );\r\n\r\n  // Test if is valid decimal\r\n  return regExp.test(input);\r\n};\r\n\r\nexport { isDecimal };\r\n"],"names":["alpha","asciiRegex","base32Regex","notBase64Regex","urlSafeBase64Regex","bech32Regex","base58Regex","isStrictJSON","input","JSON","parse","_a","isValidObject","Array","isArray","every","rgbColor","rgbaColor","rgbColorPercent","rgbaColorPercent","locale","string","replace","test","Error","length","options","isUrlSafe","len","firstPaddingChar","indexOf","delimiters","format","strictMode","Boolean","checkIsValidFormat","formatDelimiter","find","delimiter","dateDelimiter","dateObj","_i","dateAndFormat_1","date","zippedArr","Math","max","i","push","zip","split","toLowerCase","dateWord","formatWord","charAt","fullYear","y","startsWith","parsedYear","parseInt","isNaN","Date","getFullYear","concat","month","m","day","d","getUTCDate","digits","force","RegExp","array"],"mappings":"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"}