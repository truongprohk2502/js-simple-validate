{"code":"/**\n * Check is valid format with type like \"yyyy-mm-dd\", \"mm.dd.yyyy\", \"dd/mm/yy\", ...\n *\n * @param {string[]} format The format need to validate.\n * @returns {boolean} Returns true if is valid format.\n */\nvar checkIsValidFormat = function (format) {\n    return /(^(y{4}|y{2})[.\\/-](m{1,2})[.\\/-](d{1,2})$)|(^(m{1,2})[.\\/-](d{1,2})[.\\/-]((y{4}|y{2})$))|(^(d{1,2})[.\\/-](m{1,2})[.\\/-]((y{4}|y{2})$))/gi.test(format);\n};\n/**\n * Generate array of each date value and format value pairs.\n *\n * @param {string[]} date The date array.\n * @param {string[]} format The format array.\n * @returns {boolean} Returns the list of date and value pairs.\n */\nvar zip = function (date, format) {\n    var zippedArr = [];\n    var len = Math.max(date.length, format.length);\n    for (var i = 0; i < len; i++) {\n        zippedArr.push([date[i], format[i]]);\n    }\n    return zippedArr;\n};\n/**\n * Validates if the given string is date string or not.\n *\n * @param {any} input The string to validate.\n * @param {Options} options An optional configuration object.\n * @param {boolean} options.format The format of date string.\n * @param {boolean} options.strictMode Match exactly format.\n * @returns {boolean} Returns true if the string is date string, false otherwise.\n */\nvar isDate = function (input, options) {\n    // Delimiters between day,month and year\n    var delimiters = [\"/\", \"-\", \".\"];\n    // Set default options value\n    var format = (options === null || options === void 0 ? void 0 : options.format) || \"YYYY/MM/DD\";\n    var strictMode = Boolean(options === null || options === void 0 ? void 0 : options.strictMode);\n    // Returns false input is not a string\n    if (typeof input !== \"string\")\n        return false;\n    // If format is invalid, return false\n    if (!checkIsValidFormat(format))\n        return false;\n    // Find the delimiter of format string\n    var formatDelimiter = delimiters.find(function (delimiter) { return format.indexOf(delimiter) !== -1; });\n    // Find the delimiter of input string,\n    // if is in strict mode then input delimiter is the same as format delimiter\n    var dateDelimiter = strictMode\n        ? formatDelimiter\n        : delimiters.find(function (delimiter) { return input.indexOf(delimiter) !== -1; });\n    // Get the list of date value and format pairs\n    var dateAndFormat = zip(input.split(dateDelimiter), format.toLowerCase().split(formatDelimiter));\n    var dateObj = {};\n    // Iterate all date value and format pairs\n    for (var _i = 0, dateAndFormat_1 = dateAndFormat; _i < dateAndFormat_1.length; _i++) {\n        var _a = dateAndFormat_1[_i], dateWord = _a[0], formatWord = _a[1];\n        // Date value and format need to exist and have the same length\n        if (!dateWord || !formatWord || dateWord.length !== formatWord.length)\n            return false;\n        // Add value to dateObj with key is y,m,d\n        dateObj[formatWord.charAt(0)] = dateWord;\n    }\n    var fullYear = dateObj.y;\n    // Check if the year starts with a hyphen\n    if (fullYear.startsWith(\"-\"))\n        return false;\n    // Convert short year to full year\n    if (dateObj.y.length === 2) {\n        var parsedYear = parseInt(dateObj.y, 10);\n        // If year is not a number, return false\n        if (isNaN(parsedYear))\n            return false;\n        var currentYearLastTwoDigits = new Date().getFullYear() % 100;\n        // Format year based on last 2 digits\n        if (parsedYear < currentYearLastTwoDigits) {\n            fullYear = \"20\".concat(dateObj.y);\n        }\n        else {\n            fullYear = \"19\".concat(dateObj.y);\n        }\n    }\n    var month = dateObj.m;\n    // Format month if it has 1 character\n    if (dateObj.m.length === 1) {\n        month = \"0\".concat(dateObj.m);\n    }\n    var day = dateObj.d;\n    // Format day if it has 1 character\n    if (dateObj.d.length === 1) {\n        day = \"0\".concat(dateObj.d);\n    }\n    // Check if date instance is valid\n    return (new Date(\"\".concat(fullYear, \"-\").concat(month, \"-\").concat(day, \"T00:00:00.000Z\")).getUTCDate() ===\n        +dateObj.d);\n};\nexport { isDate };\n//# sourceMappingURL=is-date.js.map","references":[],"map":"{\"version\":3,\"file\":\"is-date.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/is-date.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/Projects/NPM/js-simple-validate/dist/types/is-date.d.ts","writeByteOrderMark":false,"text":"interface Options {\n    format?: string;\n    delimiters?: string[];\n    strictMode?: boolean;\n}\n/**\n * Validates if the given string is date string or not.\n *\n * @param {any} input The string to validate.\n * @param {Options} options An optional configuration object.\n * @param {boolean} options.format The format of date string.\n * @param {boolean} options.strictMode Match exactly format.\n * @returns {boolean} Returns true if the string is date string, false otherwise.\n */\ndeclare const isDate: (input: any, options?: Options) => boolean;\nexport { isDate };\n"}}
